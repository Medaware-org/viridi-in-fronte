/* tslint:disable */
/* eslint-disable */
/**
 * Medaware Catalyst
 * The API Specification for Medaware
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountUpdateRequest
 */
export interface AccountUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface AlterElementRequest
 */
export interface AlterElementRequest {
    /**
     * 
     * @type {string}
     * @memberof AlterElementRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AlterElementRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ArticleCreationRequest
 */
export interface ArticleCreationRequest {
    /**
     * 
     * @type {string}
     * @memberof ArticleCreationRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ArticleResponse
 */
export interface ArticleResponse {
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'authorId': string;
}
/**
 * 
 * @export
 * @interface BasicMaintainerResponse
 */
export interface BasicMaintainerResponse {
    /**
     * 
     * @type {string}
     * @memberof BasicMaintainerResponse
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof BasicMaintainerResponse
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof BasicMaintainerResponse
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface CatalystError
 */
export interface CatalystError {
    /**
     * 
     * @type {string}
     * @memberof CatalystError
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof CatalystError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteArticleRequest
 */
export interface DeleteArticleRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteArticleRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeleteElementRequest
 */
export interface DeleteElementRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteElementRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DeleteTopicRequest
 */
export interface DeleteTopicRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteTopicRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ElementInsertRequest
 */
export interface ElementInsertRequest {
    /**
     * 
     * @type {string}
     * @memberof ElementInsertRequest
     */
    'article': string;
    /**
     * 
     * @type {string}
     * @memberof ElementInsertRequest
     */
    'after'?: string;
    /**
     * 
     * @type {string}
     * @memberof ElementInsertRequest
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof ElementInsertRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ElementResponse
 */
export interface ElementResponse {
    /**
     * 
     * @type {string}
     * @memberof ElementResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ElementResponse
     */
    'handle': string;
}
/**
 * 
 * @export
 * @interface ElementTypeRequirement
 */
export interface ElementTypeRequirement {
    /**
     * 
     * @type {string}
     * @memberof ElementTypeRequirement
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ElementTypeRequirement
     */
    'requirements': Array<string>;
}
/**
 * 
 * @export
 * @interface GetMetaEntryValueConstraints200ResponseInner
 */
export interface GetMetaEntryValueConstraints200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetMetaEntryValueConstraints200ResponseInner
     */
    'key'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetMetaEntryValueConstraints200ResponseInner
     */
    'constraints'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MetadataCreateRequest
 */
export interface MetadataCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof MetadataCreateRequest
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataCreateRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface MetadataEntry
 */
export interface MetadataEntry {
    /**
     * 
     * @type {string}
     * @memberof MetadataEntry
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataEntry
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataEntry
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RequestGHS200Response
 */
export interface RequestGHS200Response {
    /**
     * 
     * @type {string}
     * @memberof RequestGHS200Response
     */
    'output': string;
    /**
     * 
     * @type {Array<RequestGHS200ResponseScoresInner>}
     * @memberof RequestGHS200Response
     */
    'scores': Array<RequestGHS200ResponseScoresInner>;
}
/**
 * 
 * @export
 * @interface RequestGHS200ResponseScoresInner
 */
export interface RequestGHS200ResponseScoresInner {
    /**
     * 
     * @type {string}
     * @memberof RequestGHS200ResponseScoresInner
     */
    'class': string;
    /**
     * 
     * @type {number}
     * @memberof RequestGHS200ResponseScoresInner
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface RequestOCR200Response
 */
export interface RequestOCR200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestOCR200Response
     */
    'data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TangentialLoginRequest
 */
export interface TangentialLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof TangentialLoginRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof TangentialLoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TangentialSessionResponse
 */
export interface TangentialSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof TangentialSessionResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TopicCreationRequest
 */
export interface TopicCreationRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicCreationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TopicCreationRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TopicCreationRequest
     */
    'color': string;
}
/**
 * 
 * @export
 * @interface TopicResponse
 */
export interface TopicResponse {
    /**
     * 
     * @type {string}
     * @memberof TopicResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TopicResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TopicResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TopicResponse
     */
    'color': string;
    /**
     * 
     * @type {boolean}
     * @memberof TopicResponse
     */
    'editable': boolean;
    /**
     * 
     * @type {string}
     * @memberof TopicResponse
     */
    'textColor': string;
    /**
     * 
     * @type {boolean}
     * @memberof TopicResponse
     */
    'isFallback': boolean;
}
/**
 * 
 * @export
 * @interface UpdateArticleRequest
 */
export interface UpdateArticleRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArticleRequest
     */
    'topic'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTopicRequest
 */
export interface UpdateTopicRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTopicRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTopicRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTopicRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTopicRequest
     */
    'color'?: string;
}

/**
 * AVISApi - axios parameter creator
 * @export
 */
export const AVISApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the CSS string from AVIS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAvisCss: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/avis/css`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AVISApi - functional programming interface
 * @export
 */
export const AVISApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AVISApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the CSS string from AVIS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAvisCss(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAvisCss(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AVISApi.retrieveAvisCss']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AVISApi - factory interface
 * @export
 */
export const AVISApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AVISApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the CSS string from AVIS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAvisCss(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.retrieveAvisCss(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AVISApi - object-oriented interface
 * @export
 * @class AVISApi
 * @extends {BaseAPI}
 */
export class AVISApi extends BaseAPI {
    /**
     * 
     * @summary Get the CSS string from AVIS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AVISApi
     */
    public retrieveAvisCss(options?: RawAxiosRequestConfig) {
        return AVISApiFp(this.configuration).retrieveAvisCss(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnterogradiaApi - axios parameter creator
 * @export
 */
export const AnterogradiaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Compile Anterogradia sources
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compileAnterogradia: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('compileAnterogradia', 'body', body)
            const localVarPath = `/antg/compile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnterogradiaApi - functional programming interface
 * @export
 */
export const AnterogradiaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnterogradiaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Compile Anterogradia sources
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compileAnterogradia(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compileAnterogradia(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnterogradiaApi.compileAnterogradia']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnterogradiaApi - factory interface
 * @export
 */
export const AnterogradiaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnterogradiaApiFp(configuration)
    return {
        /**
         * 
         * @summary Compile Anterogradia sources
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compileAnterogradia(body: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.compileAnterogradia(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnterogradiaApi - object-oriented interface
 * @export
 * @class AnterogradiaApi
 * @extends {BaseAPI}
 */
export class AnterogradiaApi extends BaseAPI {
    /**
     * 
     * @summary Compile Anterogradia sources
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnterogradiaApi
     */
    public compileAnterogradia(body: string, options?: RawAxiosRequestConfig) {
        return AnterogradiaApiFp(this.configuration).compileAnterogradia(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all articles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArticles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search the article base
         * @param {string} query Query String
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryArticles: async (query: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('queryArticles', 'query', query)
            const localVarPath = `/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform GHS recognition on the uploaded file
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestGHS: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('requestGHS', 'file', file)
            const localVarPath = `/ghs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform OCR on the uploaded file
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOCR: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('requestOCR', 'file', file)
            const localVarPath = `/ocr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all articles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllArticles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllArticles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.getAllArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search the article base
         * @param {string} query Query String
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryArticles(query: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryArticles(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.queryArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Perform GHS recognition on the uploaded file
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestGHS(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestGHS200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestGHS(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.requestGHS']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Perform OCR on the uploaded file
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestOCR(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestOCR200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestOCR(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.requestOCR']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all articles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArticles(options?: RawAxiosRequestConfig): AxiosPromise<Array<ArticleResponse>> {
            return localVarFp.getAllArticles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search the article base
         * @param {string} query Query String
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryArticles(query: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ArticleResponse>> {
            return localVarFp.queryArticles(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform GHS recognition on the uploaded file
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestGHS(file: File, options?: RawAxiosRequestConfig): AxiosPromise<RequestGHS200Response> {
            return localVarFp.requestGHS(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform OCR on the uploaded file
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOCR(file: File, options?: RawAxiosRequestConfig): AxiosPromise<RequestOCR200Response> {
            return localVarFp.requestOCR(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 
     * @summary Get all articles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getAllArticles(options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).getAllArticles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search the article base
     * @param {string} query Query String
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public queryArticles(query: string, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).queryArticles(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform GHS recognition on the uploaded file
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public requestGHS(file: File, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).requestGHS(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform OCR on the uploaded file
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public requestOCR(file: File, options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).requestOCR(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a stored resource
         * @param {string} id Resource ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResource: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResource', 'id', id)
            const localVarPath = `/rsrc/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a stored resource
         * @param {string} id Resource ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResource(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a stored resource
         * @param {string} id Resource ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResource(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getResource(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
    /**
     * 
     * @summary Get a stored resource
     * @param {string} id Resource ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getResource(id: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getResource(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Catalyst status endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalystStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Catalyst status endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalystStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalystStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.catalystStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * 
         * @summary Catalyst status endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalystStatus(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.catalystStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * 
     * @summary Catalyst status endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public catalystStatus(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).catalystStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TangentialAuthApi - axios parameter creator
 * @export
 */
export const TangentialAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Log-in to the Tangential system
         * @param {TangentialLoginRequest} tangentialLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tangentialLogin: async (tangentialLoginRequest: TangentialLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tangentialLoginRequest' is not null or undefined
            assertParamExists('tangentialLogin', 'tangentialLoginRequest', tangentialLoginRequest)
            const localVarPath = `/tan/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tangentialLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate the current maintainer\'s session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tangentialLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tan/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the current maintainer\'s basic info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tangentialWhoAmI: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tan/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update profile details in the system
         * @param {AccountUpdateRequest} accountUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileDetails: async (accountUpdateRequest: AccountUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountUpdateRequest' is not null or undefined
            assertParamExists('updateProfileDetails', 'accountUpdateRequest', accountUpdateRequest)
            const localVarPath = `/tan/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TangentialAuthApi - functional programming interface
 * @export
 */
export const TangentialAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TangentialAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Log-in to the Tangential system
         * @param {TangentialLoginRequest} tangentialLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tangentialLogin(tangentialLoginRequest: TangentialLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TangentialSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tangentialLogin(tangentialLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialAuthApi.tangentialLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invalidate the current maintainer\'s session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tangentialLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tangentialLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialAuthApi.tangentialLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the current maintainer\'s basic info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tangentialWhoAmI(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicMaintainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tangentialWhoAmI(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialAuthApi.tangentialWhoAmI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update profile details in the system
         * @param {AccountUpdateRequest} accountUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileDetails(accountUpdateRequest: AccountUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileDetails(accountUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialAuthApi.updateProfileDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TangentialAuthApi - factory interface
 * @export
 */
export const TangentialAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TangentialAuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Log-in to the Tangential system
         * @param {TangentialLoginRequest} tangentialLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tangentialLogin(tangentialLoginRequest: TangentialLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<TangentialSessionResponse> {
            return localVarFp.tangentialLogin(tangentialLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidate the current maintainer\'s session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tangentialLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tangentialLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the current maintainer\'s basic info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tangentialWhoAmI(options?: RawAxiosRequestConfig): AxiosPromise<BasicMaintainerResponse> {
            return localVarFp.tangentialWhoAmI(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update profile details in the system
         * @param {AccountUpdateRequest} accountUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileDetails(accountUpdateRequest: AccountUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateProfileDetails(accountUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TangentialAuthApi - object-oriented interface
 * @export
 * @class TangentialAuthApi
 * @extends {BaseAPI}
 */
export class TangentialAuthApi extends BaseAPI {
    /**
     * 
     * @summary Log-in to the Tangential system
     * @param {TangentialLoginRequest} tangentialLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialAuthApi
     */
    public tangentialLogin(tangentialLoginRequest: TangentialLoginRequest, options?: RawAxiosRequestConfig) {
        return TangentialAuthApiFp(this.configuration).tangentialLogin(tangentialLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidate the current maintainer\'s session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialAuthApi
     */
    public tangentialLogout(options?: RawAxiosRequestConfig) {
        return TangentialAuthApiFp(this.configuration).tangentialLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the current maintainer\'s basic info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialAuthApi
     */
    public tangentialWhoAmI(options?: RawAxiosRequestConfig) {
        return TangentialAuthApiFp(this.configuration).tangentialWhoAmI(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update profile details in the system
     * @param {AccountUpdateRequest} accountUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialAuthApi
     */
    public updateProfileDetails(accountUpdateRequest: AccountUpdateRequest, options?: RawAxiosRequestConfig) {
        return TangentialAuthApiFp(this.configuration).updateProfileDetails(accountUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TangentialAuxiliaryApi - axios parameter creator
 * @export
 */
export const TangentialAuxiliaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of all the possible element types alongside their requirements and value constraints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getElementTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tan/aux/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of possible values for all metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaEntryValueConstraints: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tan/aux/constraints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TangentialAuxiliaryApi - functional programming interface
 * @export
 */
export const TangentialAuxiliaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TangentialAuxiliaryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of all the possible element types alongside their requirements and value constraints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getElementTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ElementTypeRequirement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getElementTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialAuxiliaryApi.getElementTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of possible values for all metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaEntryValueConstraints(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMetaEntryValueConstraints200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaEntryValueConstraints(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialAuxiliaryApi.getMetaEntryValueConstraints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TangentialAuxiliaryApi - factory interface
 * @export
 */
export const TangentialAuxiliaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TangentialAuxiliaryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of all the possible element types alongside their requirements and value constraints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getElementTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<ElementTypeRequirement>> {
            return localVarFp.getElementTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of possible values for all metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaEntryValueConstraints(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMetaEntryValueConstraints200ResponseInner>> {
            return localVarFp.getMetaEntryValueConstraints(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TangentialAuxiliaryApi - object-oriented interface
 * @export
 * @class TangentialAuxiliaryApi
 * @extends {BaseAPI}
 */
export class TangentialAuxiliaryApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of all the possible element types alongside their requirements and value constraints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialAuxiliaryApi
     */
    public getElementTypes(options?: RawAxiosRequestConfig) {
        return TangentialAuxiliaryApiFp(this.configuration).getElementTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of possible values for all metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialAuxiliaryApi
     */
    public getMetaEntryValueConstraints(options?: RawAxiosRequestConfig) {
        return TangentialAuxiliaryApiFp(this.configuration).getMetaEntryValueConstraints(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TangentialContentApi - axios parameter creator
 * @export
 */
export const TangentialContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Switch the element to a different type
         * @param {AlterElementRequest} alterElementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alterElement: async (alterElementRequest: AlterElementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alterElementRequest' is not null or undefined
            assertParamExists('alterElement', 'alterElementRequest', alterElementRequest)
            const localVarPath = `/tan/element`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alterElementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new article
         * @param {ArticleCreationRequest} articleCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArticle: async (articleCreationRequest: ArticleCreationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleCreationRequest' is not null or undefined
            assertParamExists('createArticle', 'articleCreationRequest', articleCreationRequest)
            const localVarPath = `/tan/article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(articleCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing article
         * @param {DeleteArticleRequest} deleteArticleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticle: async (deleteArticleRequest: DeleteArticleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteArticleRequest' is not null or undefined
            assertParamExists('deleteArticle', 'deleteArticleRequest', deleteArticleRequest)
            const localVarPath = `/tan/article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteArticleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an existing element
         * @param {DeleteElementRequest} deleteElementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteElement: async (deleteElementRequest: DeleteElementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteElementRequest' is not null or undefined
            assertParamExists('deleteElement', 'deleteElementRequest', deleteElementRequest)
            const localVarPath = `/tan/element`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteElementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the rendered HTML without forcefully re-rendering
         * @param {string} id ID of the Article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchArticle: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fetchArticle', 'id', id)
            const localVarPath = `/tan/fetch/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all elements making up a given article
         * @param {string} id ID of the Article to get the elements from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleElements: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getArticleElements', 'id', id)
            const localVarPath = `/tan/elements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all metadata of a given element
         * @param {string} elementId ID of the host sequential element
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (elementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'elementId' is not null or undefined
            assertParamExists('getMetadata', 'elementId', elementId)
            const localVarPath = `/tan/metadata/{elementId}`
                .replace(`{${"elementId"}}`, encodeURIComponent(String(elementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert a new element into the article
         * @param {ElementInsertRequest} elementInsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertElement: async (elementInsertRequest: ElementInsertRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'elementInsertRequest' is not null or undefined
            assertParamExists('insertElement', 'elementInsertRequest', elementInsertRequest)
            const localVarPath = `/tan/element`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(elementInsertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of articles written by the specified selector
         * @param {string} selector Specifies the users whose articles should be listed; User ID for a specified user, \&#39;current\&#39; for the currently logged-in user, or \&#39;all\&#39; for no filtering
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArticles: async (selector: string, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selector' is not null or undefined
            assertParamExists('listArticles', 'selector', selector)
            const localVarPath = `/tan/articles/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put a metadata tag on a given sequential element
         * @param {string} elementId ID of the host sequential element
         * @param {MetadataCreateRequest} metadataCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMetadata: async (elementId: string, metadataCreateRequest: MetadataCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'elementId' is not null or undefined
            assertParamExists('putMetadata', 'elementId', elementId)
            // verify required parameter 'metadataCreateRequest' is not null or undefined
            assertParamExists('putMetadata', 'metadataCreateRequest', metadataCreateRequest)
            const localVarPath = `/tan/metadata/{elementId}`
                .replace(`{${"elementId"}}`, encodeURIComponent(String(elementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metadataCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forcefully invoke the rendering pipeline and append to cache
         * @param {string} id ID of the Article to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderArticle: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('renderArticle', 'id', id)
            const localVarPath = `/tan/render/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update various parameters of an existing article
         * @param {UpdateArticleRequest} updateArticleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticle: async (updateArticleRequest: UpdateArticleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateArticleRequest' is not null or undefined
            assertParamExists('updateArticle', 'updateArticleRequest', updateArticleRequest)
            const localVarPath = `/tan/article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArticleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TangentialContentApi - functional programming interface
 * @export
 */
export const TangentialContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TangentialContentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Switch the element to a different type
         * @param {AlterElementRequest} alterElementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alterElement(alterElementRequest: AlterElementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alterElement(alterElementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.alterElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new article
         * @param {ArticleCreationRequest} articleCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArticle(articleCreationRequest: ArticleCreationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArticle(articleCreationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.createArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an existing article
         * @param {DeleteArticleRequest} deleteArticleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArticle(deleteArticleRequest: DeleteArticleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArticle(deleteArticleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.deleteArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes an existing element
         * @param {DeleteElementRequest} deleteElementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteElement(deleteElementRequest: DeleteElementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteElement(deleteElementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.deleteElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the rendered HTML without forcefully re-rendering
         * @param {string} id ID of the Article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchArticle(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchArticle(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.fetchArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all elements making up a given article
         * @param {string} id ID of the Article to get the elements from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArticleElements(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ElementResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArticleElements(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.getArticleElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all metadata of a given element
         * @param {string} elementId ID of the host sequential element
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(elementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetadataEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(elementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.getMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Insert a new element into the article
         * @param {ElementInsertRequest} elementInsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertElement(elementInsertRequest: ElementInsertRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertElement(elementInsertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.insertElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of articles written by the specified selector
         * @param {string} selector Specifies the users whose articles should be listed; User ID for a specified user, \&#39;current\&#39; for the currently logged-in user, or \&#39;all\&#39; for no filtering
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArticles(selector: string, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArticles(selector, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.listArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Put a metadata tag on a given sequential element
         * @param {string} elementId ID of the host sequential element
         * @param {MetadataCreateRequest} metadataCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMetadata(elementId: string, metadataCreateRequest: MetadataCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMetadata(elementId, metadataCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.putMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forcefully invoke the rendering pipeline and append to cache
         * @param {string} id ID of the Article to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderArticle(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderArticle(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.renderArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update various parameters of an existing article
         * @param {UpdateArticleRequest} updateArticleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArticle(updateArticleRequest: UpdateArticleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArticle(updateArticleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TangentialContentApi.updateArticle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TangentialContentApi - factory interface
 * @export
 */
export const TangentialContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TangentialContentApiFp(configuration)
    return {
        /**
         * 
         * @summary Switch the element to a different type
         * @param {AlterElementRequest} alterElementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alterElement(alterElementRequest: AlterElementRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.alterElement(alterElementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new article
         * @param {ArticleCreationRequest} articleCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArticle(articleCreationRequest: ArticleCreationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ArticleResponse> {
            return localVarFp.createArticle(articleCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing article
         * @param {DeleteArticleRequest} deleteArticleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArticle(deleteArticleRequest: DeleteArticleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteArticle(deleteArticleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an existing element
         * @param {DeleteElementRequest} deleteElementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteElement(deleteElementRequest: DeleteElementRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteElement(deleteElementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the rendered HTML without forcefully re-rendering
         * @param {string} id ID of the Article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchArticle(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.fetchArticle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all elements making up a given article
         * @param {string} id ID of the Article to get the elements from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArticleElements(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ElementResponse>> {
            return localVarFp.getArticleElements(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all metadata of a given element
         * @param {string} elementId ID of the host sequential element
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(elementId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MetadataEntry>> {
            return localVarFp.getMetadata(elementId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Insert a new element into the article
         * @param {ElementInsertRequest} elementInsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertElement(elementInsertRequest: ElementInsertRequest, options?: RawAxiosRequestConfig): AxiosPromise<ElementResponse> {
            return localVarFp.insertElement(elementInsertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of articles written by the specified selector
         * @param {string} selector Specifies the users whose articles should be listed; User ID for a specified user, \&#39;current\&#39; for the currently logged-in user, or \&#39;all\&#39; for no filtering
         * @param {string} [query] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArticles(selector: string, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ArticleResponse>> {
            return localVarFp.listArticles(selector, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put a metadata tag on a given sequential element
         * @param {string} elementId ID of the host sequential element
         * @param {MetadataCreateRequest} metadataCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMetadata(elementId: string, metadataCreateRequest: MetadataCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<MetadataEntry> {
            return localVarFp.putMetadata(elementId, metadataCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forcefully invoke the rendering pipeline and append to cache
         * @param {string} id ID of the Article to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderArticle(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.renderArticle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update various parameters of an existing article
         * @param {UpdateArticleRequest} updateArticleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArticle(updateArticleRequest: UpdateArticleRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateArticle(updateArticleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TangentialContentApi - object-oriented interface
 * @export
 * @class TangentialContentApi
 * @extends {BaseAPI}
 */
export class TangentialContentApi extends BaseAPI {
    /**
     * 
     * @summary Switch the element to a different type
     * @param {AlterElementRequest} alterElementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public alterElement(alterElementRequest: AlterElementRequest, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).alterElement(alterElementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new article
     * @param {ArticleCreationRequest} articleCreationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public createArticle(articleCreationRequest: ArticleCreationRequest, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).createArticle(articleCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing article
     * @param {DeleteArticleRequest} deleteArticleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public deleteArticle(deleteArticleRequest: DeleteArticleRequest, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).deleteArticle(deleteArticleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an existing element
     * @param {DeleteElementRequest} deleteElementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public deleteElement(deleteElementRequest: DeleteElementRequest, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).deleteElement(deleteElementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the rendered HTML without forcefully re-rendering
     * @param {string} id ID of the Article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public fetchArticle(id: string, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).fetchArticle(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all elements making up a given article
     * @param {string} id ID of the Article to get the elements from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public getArticleElements(id: string, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).getArticleElements(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all metadata of a given element
     * @param {string} elementId ID of the host sequential element
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public getMetadata(elementId: string, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).getMetadata(elementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Insert a new element into the article
     * @param {ElementInsertRequest} elementInsertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public insertElement(elementInsertRequest: ElementInsertRequest, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).insertElement(elementInsertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of articles written by the specified selector
     * @param {string} selector Specifies the users whose articles should be listed; User ID for a specified user, \&#39;current\&#39; for the currently logged-in user, or \&#39;all\&#39; for no filtering
     * @param {string} [query] Search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public listArticles(selector: string, query?: string, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).listArticles(selector, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put a metadata tag on a given sequential element
     * @param {string} elementId ID of the host sequential element
     * @param {MetadataCreateRequest} metadataCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public putMetadata(elementId: string, metadataCreateRequest: MetadataCreateRequest, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).putMetadata(elementId, metadataCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forcefully invoke the rendering pipeline and append to cache
     * @param {string} id ID of the Article to render
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public renderArticle(id: string, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).renderArticle(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update various parameters of an existing article
     * @param {UpdateArticleRequest} updateArticleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TangentialContentApi
     */
    public updateArticle(updateArticleRequest: UpdateArticleRequest, options?: RawAxiosRequestConfig) {
        return TangentialContentApiFp(this.configuration).updateArticle(updateArticleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TopicsApi - axios parameter creator
 * @export
 */
export const TopicsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new topic
         * @param {TopicCreationRequest} topicCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTopic: async (topicCreationRequest: TopicCreationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'topicCreationRequest' is not null or undefined
            assertParamExists('createNewTopic', 'topicCreationRequest', topicCreationRequest)
            const localVarPath = `/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(topicCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing topic
         * @param {DeleteTopicRequest} deleteTopicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic: async (deleteTopicRequest: DeleteTopicRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteTopicRequest' is not null or undefined
            assertParamExists('deleteTopic', 'deleteTopicRequest', deleteTopicRequest)
            const localVarPath = `/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteTopicRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all available topics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing topic
         * @param {UpdateTopicRequest} updateTopicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopic: async (updateTopicRequest: UpdateTopicRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateTopicRequest' is not null or undefined
            assertParamExists('updateTopic', 'updateTopicRequest', updateTopicRequest)
            const localVarPath = `/topic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTopicRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicsApi - functional programming interface
 * @export
 */
export const TopicsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TopicsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new topic
         * @param {TopicCreationRequest} topicCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewTopic(topicCreationRequest: TopicCreationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewTopic(topicCreationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.createNewTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an existing topic
         * @param {DeleteTopicRequest} deleteTopicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTopic(deleteTopicRequest: DeleteTopicRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTopic(deleteTopicRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.deleteTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the list of all available topics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTopics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopicResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTopics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.getAllTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing topic
         * @param {UpdateTopicRequest} updateTopicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTopic(updateTopicRequest: UpdateTopicRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTopic(updateTopicRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TopicsApi.updateTopic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TopicsApi - factory interface
 * @export
 */
export const TopicsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TopicsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new topic
         * @param {TopicCreationRequest} topicCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTopic(topicCreationRequest: TopicCreationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewTopic(topicCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing topic
         * @param {DeleteTopicRequest} deleteTopicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(deleteTopicRequest: DeleteTopicRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTopic(deleteTopicRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all available topics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTopics(options?: RawAxiosRequestConfig): AxiosPromise<Array<TopicResponse>> {
            return localVarFp.getAllTopics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing topic
         * @param {UpdateTopicRequest} updateTopicRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTopic(updateTopicRequest: UpdateTopicRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTopic(updateTopicRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TopicsApi - object-oriented interface
 * @export
 * @class TopicsApi
 * @extends {BaseAPI}
 */
export class TopicsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new topic
     * @param {TopicCreationRequest} topicCreationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public createNewTopic(topicCreationRequest: TopicCreationRequest, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).createNewTopic(topicCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing topic
     * @param {DeleteTopicRequest} deleteTopicRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public deleteTopic(deleteTopicRequest: DeleteTopicRequest, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).deleteTopic(deleteTopicRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all available topics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public getAllTopics(options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).getAllTopics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing topic
     * @param {UpdateTopicRequest} updateTopicRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicsApi
     */
    public updateTopic(updateTopicRequest: UpdateTopicRequest, options?: RawAxiosRequestConfig) {
        return TopicsApiFp(this.configuration).updateTopic(updateTopicRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



